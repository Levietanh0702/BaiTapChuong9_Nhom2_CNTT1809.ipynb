# -*- coding: utf-8 -*-
"""BaiTapChuong9_Nhom3_cntt1809.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1x6oeDK6oZh20fn6EPviSEG4RDY3PX490

#BIỂU DIỄN ĐỒ THỊ VÀ KIỂM TRA ĐIỀU KIỆN EULER

Đề bài: Cho đồ thị có 4 đỉnh (0, 1, 2, 3) và các cạnh (0,1), (0,2), (1,3), (2,3)
"""

import math

def tao_do_thi_euler_mau():
    """Tạo một đồ thị đơn giản có chu trình Euler."""
    graph_euler = {
        0: [1, 2],
        1: [0, 3],
        2: [0, 3],
        3: [1, 2]
    }
    print("Đồ thị mẫu (danh sách kề):")
    for node, neighbors in graph_euler.items():
        print(f"Đỉnh {node}: {neighbors}")
    return graph_euler

def tinh_bac_cac_dinh(graph):
    """Tính bậc của mỗi đỉnh trong đồ thị."""
    bac_dinh = {}
    for node in graph:
        bac_dinh[node] = len(graph[node])
    return bac_dinh

def kiem_tra_lien_thong(graph):
    """Kiểm tra xem đồ thị có liên thông không."""
    if not graph: return True

    start_node = next(iter(graph))
    visited = set()
    stack = [start_node]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                stack.append(neighbor)

    return len(visited) == len(graph) # Đúng nếu tất cả đỉnh được thăm

def kiem_tra_do_thi_euler(graph):
    """Kiểm tra điều kiện để có chu trình Euler."""
    if not kiem_tra_lien_thong(graph):
        print("Đồ thị KHÔNG LIÊN THÔNG.")
        return False

    bac_dinh = tinh_bac_cac_dinh(graph)
    print("Bậc của các đỉnh:")
    for node, bac in bac_dinh.items():
        print(f"Đỉnh {node}: Bậc {bac}")
        if bac % 2 != 0:
            print("=> Đồ thị KHÔNG phải đồ thị Euler (có đỉnh bậc lẻ).")
            return False
    print("=> Đồ thị LIÊN THÔNG và tất cả đỉnh đều bậc chẵn.")
    return True

# --- Chạy thử kiểm tra điều kiện ---
my_graph = tao_do_thi_euler_mau()
if kiem_tra_do_thi_euler(my_graph):
    print("Đồ thị này có thể có chu trình Euler.")
else:
    print("Đồ thị này không có chu trình Euler.")

"""b. Yêu cầu sinh viên sửa và lý giải

•	Sửa đổi: Thêm một đỉnh mới (ví dụ: đỉnh 4) vào đồ thị my_graph mà không có cạnh nào nối với nó. Chạy lại kiem_tra_lien_thong() và giải thích kết quả.

•	Lý giải: Nếu bạn thay đổi my_graph thành 0: [1], 1: [0, 2], 2: [1], thì đồ thị này có phải là đồ thị Euler không? Tại sao?

"""

def tinh_bac_cac_dinh(graph):
    """Tính bậc của mỗi đỉnh trong đồ thị."""
    bac_dinh = {}
    for node in graph:
        bac_dinh[node] = len(graph[node])
    return bac_dinh

def kiem_tra_lien_thong(graph):
    """Kiểm tra xem đồ thị có liên thông không."""
    if not graph:
        return True

    start_node = next(iter(graph))
    visited = set()
    stack = [start_node]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                stack.append(neighbor)

    return len(visited) == len(graph)  # Đúng nếu tất cả đỉnh được thăm

def kiem_tra_euler(graph):
    """Kiểm tra xem đồ thị có chu trình Euler hay chỉ có đường đi Euler."""
    if not kiem_tra_lien_thong(graph):
        return "Đồ thị KHÔNG LIÊN THÔNG → Không có đường/chu trình Euler."

    bac_dinh = tinh_bac_cac_dinh(graph)
    bac_le = [node for node, bac in bac_dinh.items() if bac % 2 != 0]

    print("Bậc của các đỉnh:")
    for node, bac in bac_dinh.items():
        print(f"Đỉnh {node}: Bậc {bac}")

    if len(bac_le) == 0:
        return " Đồ thị có CHU TRÌNH EULER (Eulerian Circuit)."
    elif len(bac_le) == 2:
        return " Đồ thị có ĐƯỜNG ĐI EULER nhưng KHÔNG có chu trình Euler."
    else:
        return " Đồ thị KHÔNG có đường/chu trình Euler."

# --- Chạy thử ---
print("Trường hợp 1: Đồ thị mẫu Euler")
graph1 = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2]
}
print(kiem_tra_euler(graph1))
print()

print("Trường hợp 2: Thêm đỉnh cô lập 4")
graph2 = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2],
    4: []
}
print(kiem_tra_euler(graph2))
print()

print("Trường hợp 3: Đường thẳng 0-1-2")
graph3 = {
    0: [1],
    1: [0, 2],
    2: [1]
}
print(kiem_tra_euler(graph3))

"""#THUẬT TOÁN FLEURY

"""

def xoa_canh(graph, u, v):
    if v in graph.get(u, []):
        graph[u].remove(v)
    if u in graph.get(v, []):
        graph[v].remove(u)
    if not graph.get(u):
        if u in graph: del graph[u]
    if not graph.get(v):
        if v in graph: del graph[v]


def fleury_don_gian(graph_original):
    # Tạo bản sao đồ thị để không làm thay đổi đồ thị gốc
    graph = {node: list(neighbors) for node, neighbors in graph_original.items()}

    # Tính tổng số cạnh ban đầu
    num_edges_total = sum(len(neighbors) for neighbors in graph.values()) // 2

    # Kiểm tra điều kiện Euler trước khi chạy thuật toán
    if not kiem_tra_do_thi_euler(graph_original):
        print("Đồ thị không đủ điều kiện có chu trình Euler.")
        return None

    # Bắt đầu từ đỉnh 0 (hoặc bất kỳ đỉnh nào khác)
    current_vertex = 0
    circuit = [current_vertex]

    # Lặp cho đến khi tất cả các cạnh đã được đi qua
    while num_edges_total > 0:
        neighbors = list(graph.get(current_vertex, []))

        if not neighbors:
            break

        # Chọn cạnh đầu tiên có sẵn để đi
        next_vertex = neighbors[0]

        # Xóa cạnh đã chọn khỏi đồ thị
        xoa_canh(graph, current_vertex, next_vertex)
        num_edges_total -= 1

        # Thêm đỉnh tiếp theo vào chu trình và di chuyển đến đỉnh mới
        circuit.append(next_vertex)
        current_vertex = next_vertex

    # Kiểm tra xem chu trình có hợp lệ hay không
    if num_edges_total == 0 and circuit[0] == circuit[-1]:
        print("\nTìm thấy chu trình Euler:")
        print(" -> ".join(map(str, circuit)))
        return circuit
    else:
        print("\nKhông tìm thấy chu trình Euler hợp lệ (có thể còn cạnh sót hoặc không quay về được điểm đầu).")
        print(f"Số cạnh còn lại: {num_edges_total}")
        print(f"Chu trình hiện tại: {circuit}")
        return None

# --- Chạy thuật toán Fleury đơn giản ---
print("\n--- Chạy Thuật toán Fleury (đơn giản) ---")
chu_trinh = fleury_don_gian(my_graph)

"""b. Yêu cầu sinh viên sửa và lý giải

•	Sửa đổi:

Tạo một đồ thị mới: graph_moi = {0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3], 3: [0, 2]}. Đây là đồ thị hình vuông có một đường chéo.

Chạy fleury_don_gian với graph_moi. Quan sát chu trình Euler tìm được.

•	Lý giải:

Trong hàm xoa_canh, tại sao chúng ta phải xóa v khỏi danh sách kề của u và u khỏi danh sách kề của v?

Nếu một đồ thị có chu trình Euler, nhưng bạn bắt đầu thuật toán Fleury từ một đỉnh khác đỉnh 0 (ví dụ: đỉnh 1), liệu bạn có tìm được chu trình Euler không? Chu trình đó có giống hệt chu trình bắt đầu từ đỉnh 0 không?

"""

def xoa_canh(graph, u, v):
    """Xóa cạnh (u,v) khỏi đồ thị vô hướng"""
    if v in graph.get(u, []):
        graph[u].remove(v)
    if u in graph.get(v, []):
        graph[v].remove(u)


def tinh_bac_cac_dinh(graph):
    """Tính bậc các đỉnh"""
    return {node: len(neighbors) for node, neighbors in graph.items()}


def kiem_tra_lien_thong(graph):
    """Kiểm tra đồ thị có liên thông không"""
    if not graph:
        return True

    start_node = next(iter(graph))
    visited = set()
    stack = [start_node]

    while stack:
        node = stack.pop()
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                stack.append(neighbor)

    return len(visited) == len(graph)


def phan_loai_do_thi_euler(graph):
    """Phân loại đồ thị: Chu trình Euler, Đường đi Euler, hay không Euler"""
    if not kiem_tra_lien_thong(graph):
        return "not_connected"

    bac_dinh = tinh_bac_cac_dinh(graph)
    bac_le = [v for v, deg in bac_dinh.items() if deg % 2 == 1]

    if len(bac_le) == 0:
        return "eulerian"        # Chu trình Euler
    elif len(bac_le) == 2:
        return "semi_eulerian"   # Đường đi Euler
    else:
        return "not_eulerian"


def fleury(graph_original):
    """Thuật toán Fleury: Tìm đường đi / chu trình Euler"""
    # Tạo bản sao để không thay đổi đồ thị gốc
    graph = {u: list(vs) for u, vs in graph_original.items()}

    loai = phan_loai_do_thi_euler(graph)
    if loai == "not_connected":
        print(" Đồ thị không liên thông.")
        return None
    if loai == "not_eulerian":
        print(" Đồ thị không phải Euler.")
        return None

    # Chọn đỉnh bắt đầu
    if loai == "eulerian":
        start_vertex = next(iter(graph))  # bất kỳ
    else:  # semi_eulerian: bắt đầu từ 1 trong 2 đỉnh bậc lẻ
        for v, deg in tinh_bac_cac_dinh(graph).items():
            if deg % 2 == 1:
                start_vertex = v
                break

    circuit = [start_vertex]
    current = start_vertex
    num_edges = sum(len(vs) for vs in graph.values()) // 2

    while num_edges > 0:
        neighbors = graph[current]
        next_vertex = neighbors[0]  # chọn cạnh đầu tiên
        xoa_canh(graph, current, next_vertex)
        circuit.append(next_vertex)
        current = next_vertex
        num_edges -= 1

    if loai == "eulerian":
        print(" Chu trình Euler tìm được:")
    else:
        print("ℹ Đường đi Euler tìm được:")

    print(" -> ".join(map(str, circuit)))
    return circuit


# ===============================
# Chạy thử với các đồ thị
# ===============================

print("\n--- Đồ thị mẫu Euler ---")
graph1 = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2]
}
fleury(graph1)

print("\n--- Đồ thị có thêm đỉnh cô lập (4) ---")
graph2 = {
    0: [1, 2],
    1: [0, 3],
    2: [0, 3],
    3: [1, 2],
    4: []
}
fleury(graph2)

print("\n--- Đồ thị đường thẳng 0-1-2 ---")
graph3 = {
    0: [1],
    1: [0, 2],
    2: [1]
}
fleury(graph3)

print("\n--- Đồ thị hình vuông có đường chéo (0-2) ---")
graph4 = {
    0: [1, 2, 3],
    1: [0, 2],
    2: [0, 1, 3],
    3: [0, 2]
}
fleury(graph4)